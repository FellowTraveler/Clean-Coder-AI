import datetime
import os
import subprocess
from langchain_core.messages import HumanMessage


def create_script_execution_env(work_dir: str) -> str:
    """Creates a virtual environment for executing code generated by the Clean Coder."""
    work_dir = os.path.abspath(work_dir)
    env_path = os.path.join(work_dir, "env")
    if not os.path.exists(env_path):
        import venv

        venv.create(env_path, with_pip=True)
        subprocess.run([os.path.join(env_path, "bin", "pip"), "install", "-U", "pip"], check=True)
    return os.path.join(env_path, "bin", "python")


def run_script_in_env(script_path: str, work_dir: str) -> tuple[str, str]:
    """Runs generated script in a virtual environment."""
    work_dir = os.path.abspath(work_dir)
    python_path = create_script_execution_env(work_dir)
    req_file = os.path.join(work_dir, "requirements.txt")
    if os.path.exists(req_file):
        pip_path = os.path.join(os.path.dirname(python_path), "pip")
        subprocess.run([pip_path, "install", "-r", req_file], check=True)
    try:
        result = subprocess.run([python_path, script_path], capture_output=True, text=True, check=True)
        return result.stdout, result.stderr
    except subprocess.CalledProcessError as e:
        return e.stdout, e.stderr


def format_log_message(stdout: str = "", stderr: str = "", is_error: bool = False, error_msg: str = "") -> str:
    """Format logs (stdout, stderr) for insertion into the Clean Coder context."""
    message = "\n[SCRIPT EXECUTION {}]\n".format("ERROR" if is_error else "INFO")
    if error_msg:
        message += f"Error: {error_msg}\n"
    if stdout:
        message += f"STDOUT:\n{stdout}\n"
    if stderr:
        message += f"STDERR:\n{stderr}\n"

    return message


def get_executed_filename(state: dict, work_dir: str = "") -> str:
    """Extract filename of the executed script from message history.

    Searches through messages for a line starting with 'File contents:'
    followed by the filename. If work_dir is provided, checks if the file exists.

    Returns the first existing file or the first found filename if none exist.
    """
    found_filenames = []
    for message in state.get("messages", []):
        if isinstance(message.content, str) and "File contents:" in message.content:
            header_line = message.content.splitlines()[0]
            if header_line.startswith("File contents:"):
                parts = header_line.split("File contents:")[-1].split(":")
                filename = parts[0].strip()
                found_filenames.append(filename)

                if work_dir and os.path.exists(os.path.join(work_dir, filename)):
                    return filename

    return found_filenames[0] if found_filenames else ""
